{"version":3,"file":"Arguments.js","sourceRoot":"","sources":["../../src/Arguments.ts"],"names":[],"mappings":";;AAAA;IAAA;IAqCA,CAAC;IA7BU,OAAG,GAAV,UAAW,IAAa;QACpB,IAAM,WAAW,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,gBAAgB,GAAG,IAAI,GAAG,GAAG,CAAC;QACxE,OAAO,IAAI,QAAQ,CAAM,WAAW,EAAE,UAAA,CAAC;YACnC,IAAG,OAAO,IAAI,KAAK,QAAQ;gBACvB,OAAO,IAAI,CAAC;YAEhB,IAAG,OAAO,IAAI,KAAK,WAAW;gBAC1B,OAAO,IAAI,CAAC;YAEhB,IAAG,IAAI,KAAK,OAAO;gBACf,OAAO,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YAEjC,OAAO,OAAO,CAAC,KAAK,IAAI,CAAC;QAC7B,CAAC,CAAC,CAAC;IACP,CAAC;IAEM,MAAE,GAAT,UAAa,SAAgC;QACzC,OAAO,IAAI,QAAQ,CAAI,0BAA0B,GAAG,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,GAAG,GAAG,EAAE,SAAS,CAAQ,CAAC;IAC7G,CAAC;IAEc,eAAW,GAA1B,UAA2B,GAAQ;QAC/B,IAAG,OAAO,GAAG,CAAC,OAAO,KAAK,UAAU;YAChC,OAAO,GAAG,CAAC,OAAO,EAAE,CAAC;QAEzB,IAAG,OAAO,GAAG,CAAC,QAAQ,KAAK,UAAU;YACjC,OAAO,GAAG,CAAC,QAAQ,EAAE,CAAC;QAE1B,OAAO,GAAG,CAAC;IACf,CAAC;IACL,UAAC;AAAD,CAAC,AArCD,IAqCC;AArCY,kBAAG;AAuChB;IACI,kBACY,WAAmB,EACnB,gBAAqC;QADrC,gBAAW,GAAX,WAAW,CAAQ;QACnB,qBAAgB,GAAhB,gBAAgB,CAAqB;IAEjD,CAAC;IAED,0BAAO,GAAP,UAAQ,GAAM;QACV,OAAO,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC;IACtC,CAAC;IAED,2BAAQ,GAAR;QACI,OAAO,IAAI,CAAC,WAAW,CAAC;IAC5B,CAAC;IAED,0BAAO,GAAP;QACI,OAAO,IAAI,CAAC,WAAW,CAAC;IAC5B,CAAC;IACL,eAAC;AAAD,CAAC,AAlBD,IAkBC;AAlBY,4BAAQ","sourcesContent":["export class Arg {\r\n    static any()\r\n    static any<T extends 'string'>(type: T): Argument<string> & string\r\n    static any<T extends 'number'>(type: T): Argument<number> & number\r\n    static any<T extends 'boolean'>(type: T): Argument<boolean> & boolean\r\n    static any<T extends 'array'>(type: T): Argument<any[]> & any[]\r\n    static any<T extends 'function'>(type: T): Argument<Function> & Function\r\n    static any<T extends 'string'|'number'|'boolean'|'symbol'|'undefined'|'object'|'function'|'array'>(type: T)\r\n    static any(type?: string): Argument<any> & any {\r\n        const description = !type ? '{any arg}' : '{arg matching ' + type + '}';\r\n        return new Argument<any>(description, x => {\r\n            if(typeof type === 'string')\r\n                return true;\r\n\r\n            if(typeof type === 'undefined')\r\n                return true;\r\n\r\n            if(type === 'array')\r\n                return x && Array.isArray(x);\r\n\r\n            return typeof x === type;\r\n        });\r\n    }\r\n\r\n    static is<T>(predicate: (input: T) => boolean): Argument<T> & T {\r\n        return new Argument<T>('{arg matching predicate ' + this.toStringify(predicate) + '}', predicate) as any;\r\n    }\r\n\r\n    private static toStringify(obj: any) {\r\n        if(typeof obj.inspect === 'function')\r\n            return obj.inspect();\r\n\r\n        if(typeof obj.toString === 'function')\r\n            return obj.toString();\r\n\r\n        return obj;\r\n    }\r\n}\r\n\r\nexport class Argument<T> {\r\n    constructor(\r\n        private description: string,\r\n        private matchingFunction: (arg: T) => boolean\r\n    ) {\r\n    }\r\n\r\n    matches(arg: T) {\r\n        return this.matchingFunction(arg);\r\n    }\r\n\r\n    toString() {\r\n        return this.description;\r\n    }\r\n\r\n    inspect() {\r\n        return this.description;\r\n    }\r\n}"]}