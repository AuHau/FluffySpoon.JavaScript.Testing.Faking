{"version":3,"file":"Substitute.js","sourceRoot":"","sources":["../../src/Substitute.ts"],"names":[],"mappings":"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","sourcesContent":["import { ObjectSubstitute } from \"./Transformations\";\r\nimport { ProxyObjectContext, ProxyReturnValues } from \"./Context\";\r\n\r\nexport class Substitute {\r\n    static for<T>(): ObjectSubstitute<T> {\r\n        const objectContext = new ProxyObjectContext();\r\n        \r\n        let thisProxy: ObjectSubstitute<T>;\r\n        return thisProxy = new Proxy(() => { }, {\r\n            apply: (_target, _thisArg, argumentsList) => {\r\n                if (localRecord.arguments) {\r\n                    const existingCall = findOrCreateExistingCall(localRecord.calls);\r\n                    const expectedCall = findExistingCall(localRecord.expectedCalls);\r\n\r\n                    console.log(existingCall, expectedCall);\r\n                    \r\n                    if (expectedCall !== null) {\r\n\r\n                        assertExpectedCalls();\r\n                        return void 0;\r\n                    }\r\n\r\n                    existingCall.callCount++;\r\n\r\n                    if (!equals(localRecord.arguments, argumentsList))\r\n                        return void 0;\r\n\r\n                    return localRecord.shouldReturn[localRecord.currentReturnOffset++];\r\n                }\r\n\r\n                findOrCreateExistingCall(localRecord.expectedCalls);\r\n                localRecord.arguments = [...argumentsList];\r\n\r\n                return thisProxy;\r\n            },\r\n            get: (target, property) => {\r\n                if (typeof property === 'symbol') {\r\n                    if (property === Symbol.toPrimitive)\r\n                        return () => void 0;\r\n\r\n                    return void 0;\r\n                }\r\n\r\n                if (property === 'valueOf')\r\n                    return void 0;\r\n\r\n                if (property === 'toString')\r\n                    return (target[property] || '').toString();\r\n\r\n                if (property === 'inspect')\r\n                    return () => \"{SubstituteJS fake}\";\r\n\r\n                if (property === 'constructor')\r\n                    return () => thisProxy;\r\n\r\n                if (property === 'returns' && objectContext.property.type === 'object')\r\n                    return (...args: any[]) => objectContext.property.returnValues = new ProxyReturnValues(...args);\r\n\r\n                if (property === 'received') {\r\n                    return (count?: number) => {\r\n                        objectContext.setExpectedCallCount(count);\r\n                        return thisProxy;\r\n                    };\r\n                }\r\n\r\n                const existingCall = objectContext.findActualCall(property.toString(), 'read');\r\n                if(existingCall) {\r\n                    if(existingCall.property.type === 'function')\r\n                        return thisProxy;\r\n                    \r\n                    const expectedCall = objectContext.findExpectedCall(property.toString(), 'read');\r\n                    if(expectedCall && expectedCall.property.type === 'object') {\r\n                        //assert expected call matching.\r\n                    }\r\n                }\r\n\r\n                // if (existingCall) {\r\n                //     if (existingCall)\r\n                //         return thisProxy;\r\n\r\n                //     const existingCall = findOrCreateExistingCall(localRecord.calls);\r\n\r\n                //     const expectedCall = findExistingCall(localRecord.expectedCalls);\r\n                //     if (expectedCall !== null) {\r\n                //         assertExpectedCalls();\r\n                //         return void 0;\r\n                //     }\r\n\r\n                //     existingCall.callCount++;\r\n\r\n                //     return localRecord.shouldReturn[localRecord.currentReturnOffset++];\r\n                // }\r\n\r\n                // localRecord = createRecord();\r\n                // localRecord.property = property;\r\n\r\n                return thisProxy;\r\n            }\r\n        }) as any;\r\n\r\n        // const findExistingCall = (calls: Call[]) => findCallMatchingArguments(calls, localRecord.arguments);\r\n\r\n        // const findOrCreateExistingCall = (calls: Call[]) => {\r\n        //     let existingCall = findExistingCall(calls);\r\n        //     if (!existingCall) {\r\n        //         existingCall = { \r\n        //             callCount: 0, \r\n        //             arguments: localRecord.arguments,\r\n        //             name: localRecord.property.toString()\r\n        //         };\r\n        //         calls.push(existingCall);\r\n        //     }\r\n\r\n        //     return existingCall;\r\n        // };\r\n\r\n        // const assertExpectedCalls = () => {\r\n        //     const existingCall = findExistingCall(localRecord.calls);\r\n        //     if(!localRecord.arguments || localRecord.arguments.length === 0 || ((localRecord.expectedCallCount === -1 && existingCall.callCount === 0) || (localRecord.expectedCallCount !== -1 && localRecord.expectedCallCount !== existingCall.callCount))) {\r\n        //         throw new Error('Expected ' + (localRecord.expectedCallCount === -1 ? 'at least one' : localRecord.expectedCallCount) + ' call(s) to the property ' + localRecord.property + ', but received ' + existingCall.callCount + ' of such call(s).\\nOther calls received:' + stringifyCalls(localRecord.calls));\r\n        //     }\r\n\r\n        //     const expectedCall = findExistingCall(localRecord.expectedCalls);\r\n        //     if (existingCall === null || ((expectedCall.callCount === -1 && existingCall.callCount === 0) || (expectedCall.callCount !== -1 && expectedCall.callCount !== existingCall.callCount))) {\r\n        //         throw new Error('Expected ' + (expectedCall.callCount === -1 ? 'at least one' : expectedCall.callCount) + ' call(s) to the method ' + localRecord.property + ' with arguments ' + stringifyArguments(expectedCall.arguments) + ', but received ' + existingCall.callCount + ' of such call(s).\\nOther calls received:' + stringifyCalls(localRecord.calls));\r\n        //     }\r\n        // }\r\n    }\r\n}"]}